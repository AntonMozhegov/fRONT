export const lecture_4 = `
<h1>Лекция 4: Обеспечение целостности данных в базах данных: принципы и механизмы</h1>

<p><strong>Транзакции</strong> являются одной из ключевых концепций в разработке приложений, работающих с базами данных. Spring Data JPA предоставляет мощные и удобные инструменты для управления транзакциями. Транзакция — это последовательность операций, которая выполняется как единое целое, обеспечивая целостность данных и согласованность состояния базы данных даже в случае ошибок или сбоев. В контексте Spring Data JPA транзакции тесно связаны с JPA и Hibernate, а также с общей инфраструктурой Spring Framework, что позволяет разработчикам легко управлять транзакциями, минимизировать риски и обеспечивать надёжность приложений.</p>

<h2>Базовая теория транзакций</h2>

<p>Транзакция в контексте баз данных — это логическая единица работы, которая состоит из одной или нескольких операций (например, чтение, запись, обновление или удаление данных). Все операции в рамках транзакции должны либо успешно завершиться (транзакция фиксируется, или "коммитится"), либо быть полностью отменены (транзакция откатывается, или "роллбэк") в случае ошибки или сбоя. Транзакции играют критически важную роль в обеспечении целостности данных, особенно в многопользовательских системах, где несколько клиентов могут одновременно обращаться к базе данных.</p>

<h3>Пример простейшей транзакции:</h3>

<p>Перевод денег между двумя банковскими счетами. Эта операция включает два шага:</p>
<ol>
  <li>Снятие денег с одного счёта.</li>
  <li>Зачисление денег на другой счёт.</li>
</ol>

<p>Если произойдёт сбой после первого шага, но до выполнения второго, система может оказаться в несогласованном состоянии (деньги сняты, но не зачислены). Транзакция гарантирует, что либо оба шага будут выполнены, либо ни один из них не будет применён.</p>

<h2>Свойства транзакций (ACID)</h2>

<p>Транзакции обладают четырьмя основными свойствами, которые обозначаются аббревиатурой ACID:</p>

<ul>
  <li><strong>Atomicity (Атомарность)</strong> — гарантирует, что все операции в рамках транзакции выполняются как единое целое. Если хотя бы одна операция не может быть выполнена, все изменения, сделанные в рамках транзакции, откатываются, и база данных возвращается в исходное состояние.</li>
  <li><strong>Consistency (Согласованность)</strong> — гарантирует, что транзакция переводит базу данных из одного согласованного состояния в другое, соблюдая все правила, ограничения, целостность данных и бизнес-логику. Например, если в таблице есть ограничение уникальности на поле email, транзакция не должна нарушить это ограничение.</li>
  <li><strong>Isolation (Изоляция)</strong> — гарантирует, что транзакции выполняются независимо друг от друга. Даже если несколько транзакций выполняются одновременно, каждая из них изолирована, и промежуточные изменения одной транзакции не видны другим до её завершения. Уровень изоляции может быть настроен, чтобы балансировать между производительностью и строгостью изоляции.</li>
  <li><strong>Durability (Долговечность)</strong> — гарантирует, что после успешного завершения транзакции (фиксации) все изменения сохраняются в базе данных, даже в случае сбоя системы (например, отключения питания). Это достигается за счёт журналирования и других механизмов СУБД.</li>
</ul>

<h2>Управление транзакциями в Spring Data JPA</h2>

<p>В Spring Data JPA управление транзакциями основано на инфраструктуре Spring Framework, которая предоставляет декларативный и программный подходы к управлению транзакциями. Декларативный подход, использующий аннотацию <code>@Transactional</code>, является наиболее распространённым, так как он позволяет разработчикам сосредоточиться на бизнес-логике, а не на низкоуровневых деталях управления транзакциями. Программный подход, использующий <code>TransactionTemplate</code> или <code>PlatformTransactionManager</code>, применяется реже, в основном в сложных сценариях, требующих тонкой настройки.</p>

<h3>Декларативное управление транзакциями с помощью @Transactional</h3>

<p>Аннотация <code>@Transactional</code> — это основной инструмент для управления транзакциями в Spring. Она указывает, что метод или класс должен выполняться в рамках транзакции. Spring автоматически начинает транзакцию перед вызовом метода, фиксирует её (commit) при успешном завершении метода или откатывает (rollback) в случае возникновения ошибки.</p>

<pre><code class="language-java">import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void transferMoney(Long fromUserId, Long toUserId, double amount) {
        User fromUser = userRepository.findById(fromUserId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));
        User toUser = userRepository.findById(toUserId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        fromUser.setBalance(fromUser.getBalance() - amount);
        toUser.setBalance(toUser.getBalance() + amount);

        userRepository.save(fromUser);
        userRepository.save(toUser);
    }
}
</code></pre>

<p>В этом примере:</p>
<ul>
  <li>Метод <code>transferMoney</code> выполняется в рамках одной транзакции благодаря аннотации <code>@Transactional</code>.</li>
  <li>Если произойдёт ошибка (например, недостаточно средств на счёте отправителя или сбой базы данных), все изменения (снятие денег с одного счёта и зачисление на другой) будут откатаны, и база данных останется в исходном состоянии.</li>
  <li>Если метод завершится успешно, транзакция будет зафиксирована, и изменения сохранятся в базе данных.</li>
</ul>

<h3>Настройка поведения транзакций</h3>

<p>Аннотация <code>@Transactional</code> предоставляет множество параметров для настройки поведения транзакции. Рассмотрим основные из них:</p>

<ul>
  <li><strong>propagation (Распространение транзакции)</strong> — определяет, как транзакция ведёт себя, если метод вызывается в контексте уже существующей транзакции. Возможные значения:
    <ul>
      <li><code>Propagation.REQUIRED</code> (по умолчанию) — если уже существует транзакция, метод присоединяется к ней; если транзакции нет, создаётся новая.</li>
      <li><code>Propagation.REQUIRES_NEW</code> — всегда создаётся новая транзакция, а существующая транзакция приостанавливается до завершения новой.</li>
      <li><code>Propagation.NESTED</code> — создаётся вложенная транзакция, которая является частью внешней транзакции, но может быть откатана независимо.</li>
      <li><code>Propagation.MANDATORY</code> — требует, чтобы метод вызывался в существующей транзакции; если транзакции нет, выбрасывается исключение.</li>
      <li><code>Propagation.NOT_SUPPORTED</code> — метод выполняется вне транзакции; если существует транзакция, она приостанавливается.</li>
      <li><code>Propagation.NEVER</code> — метод не должен выполняться в транзакции; если транзакция существует, выбрасывается исключение.</li>
      <li><code>Propagation.SUPPORT</code> — метод может выполняться как в транзакции, так и без неё; если транзакция существует, метод присоединяется к ней.</li>
    </ul>
  </li>
  <li><strong>isolation (Уровень изоляции)</strong> — определяет, как транзакции изолированы друг от друга. Уровень изоляции влияет на видимость изменений, сделанных одной транзакцией, для других транзакций. Возможные значения:
    <ul>
      <li><code>Isolation.DEFAULT</code> (по умолчанию) — используется уровень изоляции, заданный базой данных (обычно READ_COMMITTED для большинства СУБД).</li>
      <li><code>Isolation.READ_UNCOMMITTED</code> — самая низкая изоляция, допускает "грязное чтение".</li>
      <li><code>Isolation.READ_COMMITTED</code> — предотвращает "грязное чтение", но допускает "неповторяющееся чтение" и "фантомное чтение".</li>
      <li><code>Isolation.REPEATABLE_READ</code> — предотвращает "грязное чтение" и "неповторяющееся чтение", но допускает "фантомное чтение".</li>
      <li><code>Isolation.SERIALIZABLE</code> — самая строгая изоляция, предотвращает все аномалии.</li>
    </ul>
  </li>
  <li><strong>timeout (Тайм-аут)</strong> — задаёт максимальное время (в секундах), в течение которого транзакция должна завершиться.</li>
  <li><strong>readOnly (Только для чтения)</strong> — указывает, что транзакция предназначена только для чтения данных.</li>
  <li><strong>rollbackFor и noRollbackFor (Управление откатом)</strong> — позволяют настроить, при каких исключениях транзакция должна откатываться или, наоборот, не откатываться.</li>
</ul>

<h3>Программное управление транзакциями</h3>

<p>Хотя декларативный подход с <code>@Transactional</code> покрывает большинство сценариев, в некоторых случаях требуется программное управление транзакциями. Для этого Spring предоставляет два инструмента:</p>

<ul>
  <li><code>TransactionTemplate</code> — удобный способ выполнения кода в транзакции.</li>
  <li><code>PlatformTransactionManager</code> — низкоуровневый API для управления транзакциями.</li>
</ul>

<h2>Обработка ошибок в транзакциях</h2>

<p>По умолчанию Spring откатывает транзакцию при возникновении <code>RuntimeException</code> или <code>Error</code>, но не при Checked Exception. Это поведение можно изменить с помощью параметров <code>rollbackFor</code> и <code>noRollbackFor</code>. Важно также понимать, что откат транзакции не происходит автоматически, если исключение "поглощается" (caught) внутри метода, но не выбрасывается дальше.</p>

<h2>Вывод лекции</h2>

<p>В рамках лекции рассматриваются ключевые аспекты работы с транзакциями в Spring Data JPA и их роль в обеспечении целостности данных при взаимодействии с базами данных. Транзакции представляют собой последовательность операций, которые выполняются как единое целое и обладают свойствами ACID: атомарностью, согласованностью, изоляцией и долговечностью, что гарантирует корректность работы системы даже в случае ошибок или сбоев. Управление транзакциями в Spring Data JPA осуществляется через декларативный подход с использованием аннотации <code>@Transactional</code>, которая позволяет автоматически начинать, фиксировать или откатывать транзакции в зависимости от успешности выполнения метода. При этом аннотация предоставляет множество параметров для настройки поведения транзакций, таких как уровень изоляции, тайм-аут, распространение и режим только для чтения, что делает её гибким инструментом для различных сценариев.</p>

<p>Помимо декларативного подхода, Spring также поддерживает программное управление транзакциями через <code>TransactionTemplate</code> и <code>PlatformTransactionManager</code>, что может быть полезно в сложных случаях, требующих ручного контроля. Важным аспектом является обработка ошибок, так как по умолчанию Spring откатывает транзакцию только при возникновении <code>RuntimeException</code> или <code>Error</code>, но это поведение можно настроить с помощью параметров <code>rollbackFor</code> и <code>noRollbackFor</code>. Кроме того, все методы репозиториев в Spring Data JPA по умолчанию выполняются в транзакционном контексте, что упрощает работу с базой данных и минимизирует необходимость явного управления транзакциями. Использование транзакций особенно важно в многопользовательских системах, где требуется обеспечить согласованность данных, например, при выполнении операций перевода денег между счетами или других сценариев изменения состояния системы.</p>`;
