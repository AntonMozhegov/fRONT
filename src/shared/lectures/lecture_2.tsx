export const lecture_2 = `
<h1>Библиотека React: react-hooks и отличия виртуального DOM от обычного</h1>
<p>Для начала вспомним что такое <strong>DOM</strong> из предыдущей лекции так как знание принципов его работы необходимо для понимания работы библиотеки React. <em>DOM (Document Object Model)</em> — это внутренняя структура HTML-документа (дерево элементов), которую браузер создаёт после загрузки страницы. Строится оно на основе тегов, таким образом браузер строит это дерево и показывает его пользователю в виде визуального интерфейса.</p>

<p>Понимание принципов работы DOM имеет ключевое значение для эффективной разработки пользовательских интерфейсов. Однако по мере усложнения веб-приложений и роста объёмов динамически обновляемого контента, разработчики столкнулись с ограничениями производительности, связанными с непосредственным взаимодействием с реальным DOM. В ответ на эти вызовы были разработаны новые подходы и инструменты, направленные на оптимизацию рендеринга и управление состоянием интерфейса. Одним из таких решений стала библиотека <strong>React</strong>, предложившая инновационную концепцию виртуального DOM и ряд средств для эффективной работы с компонентами. В данном докладе мы подробно рассмотрим три ключевых аспекта React, которые сделали эту библиотеку столь востребованной в современной веб-разработке: виртуальный DOM, React Hooks и декларативно-компонентный подход.</p>

<h3>Виртуальный DOM: определение и принцип работы React</h3> 
<p><strong>Виртуальный DOM</strong> — это лёгкая копия реального DOM, которая хранится в оперативной памяти. React сначала вносит изменения в Virtual DOM, затем сравнивает обновлённую версию с предыдущей (процесс «диффинг») и применяет к настоящему DOM только те правки, которые действительно изменились. Такой подход сокращает число дорогостоящих перерисовок и повышает производительность интерфейса.</p>

<p>Таким образом реакт сравнивает изменения в виртуальном DOM и применяет только необходимые правки вместо постоянного обновления реального DOM, что сокращает количество перерисовок и повышает скорость работы интерфейса. Так же еще одно преимущество реакта -  это эффективное обновление. React группирует несколько изменений и применяет их одновременно, уменьшая нагрузку на браузер и обеспечивая более плавные анимации и переходы.</p>

<h3>Разберём более детально алгоритм того, как реакт обновляет интерфейс</h3>
<ol>
  <li>
    <p>Создание виртуального DOM</p>
    <p>Когда реакт впервые рендерит ваши компоненты, он строит лёгкую Virtual DOM. Эта структура отражает текущее состояние дерева компонентов и их элементов (теги, свойства, текст). React не взаимодействует напрямую с браузером на этом этапе: всё происходит в памяти, что обеспечивает высокую скорость операций.</p>
  </li>
  <li>
    <p>Сравнение версий (диффинг)</p>
    <p>При обновлении состояния или свойств компонентов React заново выполняет функцию рендера и получает новую версию Virtual DOM. Затем происходит «диффинг»: React проходит по двум деревьям (старому и новому) и обнаруживает изменения. Для ускорения сравнения используются выделение минимальных отличий — React не проверяет глубоко всё дерево, а только тропы, где произошли изменения </p>
  </li>
  <li>
    <p>Обновление реального DOM (патчинг)</p>
    <p>После того как React определил, какие элементы Virtual DOM изменились, он формирует набор «патчей» — точечных инструкций для реального DOM. Эти патчи могут включать:</p>
    <ul>
      <li>Добавление или удаление элементов.</li>
      <li>Изменение самих тегов и текстового содержимого.</li>
      <li>Перемещение узлов (элементов DOM, html-тегов) внутри родительского элемента.</li>
    </ul>
    <p>Далее React применяет все патчи одной группой, чтобы свести к минимуму обращения к реальному DOM. Благодаря этому достигается высокая производительность и плавность интерфейса. </p>
  </li>
</ol>

<p>На этом этапе мы разобрались, как реакт отслеживает и вносит изменения в интерфейс. Теперь, когда механизм обновления DOM понятен, давайте перейдём к другому ключевому элементу, хукам реакта( React Hooks). Они позволяют более гибко управлять состоянием внутри функциональных компонентов.</p>
<p><strong>Зачем компонентам нужно своё состояние?</strong> Состояние - это набор данных, которые определяют текущее поведение и отображение компонента. Когда эти данные меняются (например, счётчик кликов или содержимое формы), компонент должен «запомнить» новое значение и обновить интерфейс. Без состояния компоненты были бы чистыми функциями, которые не могут хранить информацию между перерисовками и реагировать на взаимодействие пользователя. В разработке на чистом js так же разработчики должны в ручную обновлять интерфейс. Это значит что они должны писать функции, которые будут отслеживать то, не изменилось ли значение внутри них, и в случае положительного исхода - перерисовывать себя. Такой подход значительно усложняет разработку так как добавляет много рутины в простые действия. Эту проблему и решает реакт за счет хуков и тем, как они работают с состоянием</p>

<h3>React Hooks</h3>

<p><strong>React Hooks</strong> — это простые функции, которые дают функциональным компонентам «память» и возможность выполнять дополнительные действия. Например, с помощью хука <code>useState</code> компонент может «запоминать» число кликов кнопки, а с помощью <code>useEffect</code> — автоматически загружать данные с сервера при появлении на странице. Представьте, что вы готовите кофе: <code>useState</code> — это как счётчик чашек, которые вы уже сделали, а <code>useEffect</code> — таймер, который оповещает вас, когда напиток готов.</p>

<h3>Основные хуки React</h3>

<h4>useState</h4>
<p>Представьте, что ваш компонент - это лист бумаги, а <code>useState</code> даёт вам карандаш и резинку: вы можете написать число (значение состояния) и при необходимости стереть и переписать его. Вот его синтаксис:</p>
<pre><code>const [value, setValue] = useState(initialValue);</code></pre>

<ul>
  <li><strong>initialValue</strong> — стартовое значение (число, строка, объект и т. д.).</li>
  <li><strong>value</strong> — текущий «записанный» карандашом текст.</li>
  <li><strong>setValue</strong> — функция, чтобы стереть старое и записать новое.</li>
</ul>
<p>Когда вы вызываете <code>setValue(newValue)</code>, React понимает что в компоненте что-то изменилось и перерисовывает компонент, подставляя новое значение в интерфейс. Без <code>useState</code> функциональные компоненты — это чистые функции без памяти, а с ним они «запоминают» свои данные между рендерами.</p>

<h4>useEffect</h4>
<p><code>useEffect</code> позволяет выполнить «побочное» действие после того, как React обновил DOM, и при необходимости убрать за собой через функцию очистки.</p>

<pre><code>useEffect(() =&gt; {
  // действие: например, подписка на событие
  window.addEventListener('resize', handleResize);

  // очистка: убираем подписку, когда компонент изменится или удалится
  return () =&gt; {
    window.removeEventListener('resize', handleResize);
  };
}, [dependencies]);</code></pre>
<p><strong>дополнительно</strong>: addEventListener - встроенная в js функция, которая позволяет вешать слушатель событий на определенные элементы. В нашем случае мы повесли слушатель события на событие "resize", а вторым аргументом подали функцию, в которую могли положить любую логику</p>

<ul>
  <li>
    <strong>Первый аргумент</strong> — функция-эффект, в которой вы описываете действие.  
    <p>Например, добавить слушатель события <code>resize</code>, чтобы реагировать на изменение размеров окна.</p>
  </li>
  <li>
    <strong>Возвращаемая функция</strong> — очистка эффекта.  
    <p>Она выполняется перед следующим запуском эффекта и при удалении компонента, то есть когда компонент "размонтируется" или удаляется. В примере мы снимаем слушатель, чтобы не было «висящих» подписок, которые могли бы привести к утечкам памяти</p>
  </li>
  <li>
    <strong>dependencies</strong> — массив зависимостей.  
    <p>Эффект будет повторно выполняться только когда изменится хотя бы одна переменная из этого массива. Пустой массив (<code>[]</code>) означает: выполнить один раз при монтировании.</p>
  </li>
</ul>


<p>Таким образом, <code>useEffect</code> — это как напоминалка «сделать что-то» после того, как React обновил интерфейс, с возможностью аккуратно «убирать за собой» через функцию очистки и гибко настраивать момент запуска через массив зависимостей.</p>

<h4>useContext</h4>
<p><strong>useContext</strong> позволяет передавать общие данные (например, тему оформления или информацию о пользователе) сразу в любой компонент без передачи пропсов через все уровни вложенности. Представьте, что вы хотите знать текущую тему (“светлая” или “тёмная”) во многих местах приложения — вместо того чтобы явно прокидывать её через каждую функцию-компоненту, вы создаёте «контекст» и потом просто «достаете» нужное значение там, где оно нужно.</p>
<p>Пример из практики: вы задаёте тему в одном месте, а внутри глубокого вложенного меню или кнопки получаете её через <code>useContext</code> и меняете стили автоматически.</p><pre><code>const value = useContext(MyContext);</code></pre>
<p>Перейдем к реальному примеру того, как создать и использовать контекст. Его создание состоит из двух шагов:</p>

<ol>
  <li>
    <p><strong>Обёртка провайдера</strong></p>
    <pre><code>
// создаём контекст с значением по умолчанию
const MyContext = React.createContext('default');

// компонент-обёртка, который задаёт актуальное значение и оборачивает детей
function MyProvider({ children }) {
  const sharedValue = 'нужные данные'; // например, тема или информация о пользователе
  return (
    &lt;MyContext.Provider value={sharedValue}&gt;
      {children}
    &lt;/MyContext.Provider&gt;
  );
}

// в корневом компоненте
function App() {
  return (
    &lt;MyProvider&gt;
      &lt;MainComponent /&gt;
    &lt;/MyProvider&gt;
  );
}
    </code></pre>
  </li>
  <li>
    <p><strong>Получение данных в дочерних компонентах</strong></p>
    <pre><code>
function ChildComponent() {
  // достаём значение из контекста
  const value = useContext(MyContext);

  return (
    &lt;div&gt;
      Текущее значение: {value}
    &lt;/div&gt;
  );
}
    </code></pre>
  </li>
</ol>
<p>Так ваши компоненты сразу получают нужные данные, не таща их через пропсы. Это особенно удобно для темизации, авторизации, настроек локали и любых других «глобальных» данных.</p>

<p>Теперь, когда мы подробно изучили виртуальный DOM, разобрали алгоритм его обновления и освоили основные React Hooks, можно перейти к итогам. Использование React вместе с хуками даёт разработчикам по-настоящему ускоренный и удобный рабочий процесс. Благодаря виртуальному DOM React «сравнивает» изменения и вносит только необходимые правки в интерфейс. Примером из жизни может послужит то, что мы можем менять одну лампочку в доме, а не перекрашивать все стены в нем</p>

<p>Хуки реакта предоставляют функциональным компонентам «память» и набор инструментов: с помощью <code>useState</code> мы сохраняем и обновляем состояние, с <code>useEffect</code> — организуем побочные операции без громоздких классов, а <code>useContext</code> позволяет легко делиться данными по всему приложению без многократной передачи пропсов. В совокупности эти подходы делают код чище, избавляют от рутинной работы и позволяют сосредоточиться на логике приложения, а не на деталях взаимодействия с реальным DOM.</p>


<h2>Вопросы:</h2>
<ol>
  <li>Что такое DOM и зачем важно понимать его структуру при разработке UI?</li>
  <li>Почему прямые манипуляции с реальным DOM могут замедлять сложные веб-приложения?</li>
  <li>Что такое виртуальный DOM и в чём его отличие от реального DOM?</li>
  <li>Какие три этапа включает алгоритм обновления интерфейса через виртуальный DOM в React?</li>
  <li>Как виртуальный DOM помогает избежать лишних перерисовок и повысить производительность?</li>
  <li>Зачем компонентам React нужно собственное состояние и как это упрощает разработку?</li>
  <li>Что такое React Hooks и какую проблему они решают в функциональных компонентах?</li>
  <li>Для чего используется хук <code>useState</code> и как с его помощью «запоминать» данные между рендерами?</li>
  <li>Как работает хук <code>useEffect</code>, и зачем нужна его функция очистки и массив зависимостей?</li>
  <li>Что решает хук <code>useContext</code> и как он избавляет от «проброса» пропсов через множество уровней?</li>
</ol>
`;
